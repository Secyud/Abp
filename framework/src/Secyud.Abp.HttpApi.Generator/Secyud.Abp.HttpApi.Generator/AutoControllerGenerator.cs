using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Secyud.Abp.HttpApi.Generator;

[Generator]
public class AutoControllerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: Collect candidate class declarations with the [GenerateControllerFor] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: static (ctx, _) =>
                {
                    var classSymbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol;

                    var attributes = classSymbol?.GetAttributes();

                    var controllerAttribute = attributes?.FirstOrDefault(attr =>
                        attr.AttributeClass?.Name.EndsWith("AutoControllerAttribute") == true);

                    return (ClassSymbol: classSymbol, AttributeData: controllerAttribute);
                })
            .Where(static data => data != default);

        // Step 2: Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Step 3: Register the source output
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(spc, source.Right));
    }

    private static void Execute(SourceProductionContext context,
        ImmutableArray<(INamedTypeSymbol? ClassSymbol, AttributeData? AttributeData)> candidates)
    {
        foreach (var (classSymbol, attributeData) in candidates)
        {
            if (classSymbol == null || attributeData == null) continue;

            var interfaceType = attributeData.ConstructorArguments[0];
            if (interfaceType.IsNull || interfaceType.Kind != TypedConstantKind.Type ||
                interfaceType.Value is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }

            var areaAttribute = classSymbol.GetAttributes().FirstOrDefault(attr =>
                attr.AttributeClass?.Name.EndsWith("AreaAttribute") == true);

            var moduleName = UpperCamelCaseToRoute(areaAttribute?.ConstructorArguments[0].Value as string ?? "app");

            // 生成 partial 类代码
            var source = GenerateControllerSource(classSymbol, interfaceSymbol,moduleName);
            context.AddSource($"{classSymbol.Name}.controller.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static string GenerateControllerSource(
        INamedTypeSymbol classSymbol,
        INamedTypeSymbol interfaceSymbol,
        string moduleName)
    {
        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var interfaceName = interfaceSymbol.Name;

        var sb = new StringBuilder();
        sb.AppendLine(
            $$"""
              // <auto-generated />
              using Microsoft.AspNetCore.Mvc;
              using Volo.Abp;
              using Volo.Abp.Application.Dtos;
              namespace {{namespaceName}};
              [Route("api/{{moduleName}}/{{UpperCamelCaseToRoute(className.Replace("Controller", ""))}}")]
              public partial class {{className}}({{interfaceName}} service) : {{interfaceName}}
              {
                  private readonly {{interfaceName}} _service = service;
                  
              """);

        var allMethods = GetAllMethods(interfaceSymbol);
        foreach (var method in allMethods)
        {
            if (method.MethodKind != MethodKind.Ordinary) continue;

            var httpAttribute = InferHttpAttribute(method);
            var route = InferRoute(method);

            sb.AppendLine(
                $$"""
                      [{{httpAttribute}}{{route}}]
                      public {{method.ReturnType}} {{method.Name}}({{string.Join(", ", method.Parameters.Select(p => $"{p.Type} {p.Name}"))}})
                      {
                          return _service.{{method.Name}}({{string.Join(", ", method.Parameters.Select(p => p.Name))}});
                      }
                      
                  """);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static IEnumerable<IMethodSymbol> GetAllMethods(INamedTypeSymbol interfaceSymbol)
    {
        var methods = new HashSet<IMethodSymbol>(SymbolEqualityComparer.Default);
        var visited = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<INamedTypeSymbol>();

        queue.Enqueue(interfaceSymbol);
        visited.Add(interfaceSymbol);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            foreach (var method in current.GetMembers().OfType<IMethodSymbol>())
            {
                if (method.MethodKind == MethodKind.Ordinary)
                {
                    methods.Add(method);
                }
            }

            foreach (var baseInterface in current.Interfaces)
            {
                if (visited.Add(baseInterface))
                {
                    queue.Enqueue(baseInterface);
                }
            }
        }

        return methods;
    }

    private static string UpperCamelCaseToRoute(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;

        List<char> chars = [];
        var preIsUpper = false;
        var prePreIsUpper = false;

        for (int i = name.Length - 1; i >= 0; i--)
        {
            var c = name[i];
            if (char.IsLower(c) && preIsUpper)
                chars.Add('-');

            if (char.IsUpper(c) && preIsUpper && !prePreIsUpper)
                chars.Add('-');

            var l = char.ToLowerInvariant(c);
            chars.Add(l);
            prePreIsUpper = preIsUpper;
            preIsUpper = char.IsUpper(c);
        }

        chars.Reverse();
        var sb = new StringBuilder();
        foreach (var c in chars)
            sb.Append(c);
        return sb.ToString();
    }

    private static string InferHttpAttribute(IMethodSymbol method)
    {
        if (method.Name.StartsWith("Get")) return "HttpGet";
        if (method.Name.StartsWith("Create") || method.Name.StartsWith("Post")) return "HttpPost";
        if (method.Name.StartsWith("Update") || method.Name.StartsWith("Put")) return "HttpPut";
        if (method.Name.StartsWith("Delete")) return "HttpDelete";
        return "HttpPost"; // 默认
    }

    private static string InferRoute(IMethodSymbol method)
    {
        switch (method.Name)
        {
            case "GetAsync" or "UpdateAsync" or "DeleteAsync":
                return "(\"{id:guid}\")";
            case "GetListAsync" or "CreateAsync":
                return "";
            default:
                var nameWithoutPrefix = method.Name;
                if (nameWithoutPrefix.StartsWith("Get"))
                    nameWithoutPrefix = nameWithoutPrefix.Substring(3);
                else if (nameWithoutPrefix.StartsWith("Update") ||
                         nameWithoutPrefix.StartsWith("Delete") ||
                         nameWithoutPrefix.StartsWith("Create"))
                    nameWithoutPrefix = nameWithoutPrefix.Substring(6);
                if (nameWithoutPrefix.EndsWith("Async"))
                    nameWithoutPrefix = nameWithoutPrefix.Substring(0, nameWithoutPrefix.Length - 5);

                var suffix = "";
                if (method.Parameters.Length > 0)
                {
                    var typeName = method.Parameters[0].Type.Name;
                    var paramName = method.Parameters[0].Name;
                    if (typeName == typeof(Guid).FullName)
                    {
                        suffix = $"/{{{paramName}:guid}}";
                    }
                    else if (typeName == typeof(string).FullName)
                    {
                        suffix = $"/{{{paramName}:string}}";
                    }
                    else if (typeName == typeof(int).FullName)
                    {
                        suffix = $"/{{{paramName}:int}}";
                    }
                }

                return $"(\"{UpperCamelCaseToRoute(nameWithoutPrefix)}{suffix}\")";
        }
    }
}